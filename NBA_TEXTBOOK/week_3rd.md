## <br><b>Time Complexity(시간 복잡도)</b>

  <br>알고리즘의 로직을 코드로 구현할 때, 시간 복잡도를 고려한다는 것은 입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가? 와 같습니다. 즉 효율적인 알고리즘을 구현한다는 것은 입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘이라고 말할 수 있습니다.

  <br><b>시간 복잡도를 표기하는 방법</b>

- 최악의 경우 : Big-O(빅-오) ⇒ 상한 점근

- 최선의 경우 : Big-Ω(빅-오메가) ⇒ 하한 점근

- 중간의 경우 : Big-θ(빅-세타) ⇒ 그 둘의 평균

<br> Big-O 표기법은 최악의 경우를 고려하므로, 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려할 수 있다.

<br>

- N줄덧셈

```python
# N줄덧셈
T = int(input())
print(T * (T + 1) // 2)

# 1. 등차수열의 합 공식
# 시간복잡도 : O(4) = O(1)
# sum = N * (N + 1) // 2

# 2. 1부터 N까지 반복문을 돌며 합을 계산
# 시간복잡도 : O(N)
# sum = 0
# for i in range(1, N + 1):
# sum += i
```

<br>

- 1초가 걸릴 때 입력의 최대 크기
  
  - O(N) : 약 1억
  - O(N^2) : 약 1만
  - O(N^3) : 약 500
  - O(2^N) : 약 20
  - O(N!) : 10

<br>

## <br><b>zip</b>

<br> <code>zip()</code> 함수는 여러 개의 iterable한 객체를 인자로 받고 각 객체가 담고 있는 원소를 튜플의 형태로 차례로 접근할 수 있는 반복자(iterator)를 반환합니다.

<br>

```python
open_brackets = ['(', '[', '{', '<']
closed_brackets = [')', ']', '}', '>']

for pair in zip(open_brackets, closed_brackets):
print(pair)


# ('(', ')')
# ('[', ']')
# ('{', '}')
# ('<', '>')
```

<br>

위 코드와 같이, <code>zip()</code> 함수를 사용하면 마치 옷의 지퍼를 올리는 것처럼 양 측에 있는 데이터를 하나씩 차례로 짝을 지어줍니다.

<br>

- <b>활용 예시</b>

```python
# 2차원 리스트 다루기

a = [
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 9]
]

# 90도 회전
rotated_a = list(zip(*a[::-1]))
# [
# [7, 4, 1],
# [8, 5, 2],
# [9, 6, 3]
# ]

# 행과 열 바꾸기
change_row_and_col_a = list(zip(*a))
# [
# [1, 4, 7],
# [2, 5, 8],
# [3, 6, 9]
# ]
```

<hr>

출처 : [ONOFF.log](https://velog.io/@hongin/python2%EC%B0%A8%EC%9B%90-%EB%A6%AC%EC%8A%A4%ED%8A%B8-90%EB%8F%84-%ED%9A%8C%EC%A0%84-%ED%96%89%EA%B3%BC-%EC%97%B4-%EB%B0%94%EA%BE%B8%EA%B8%B0)