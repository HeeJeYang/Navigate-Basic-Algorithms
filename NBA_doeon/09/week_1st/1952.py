# 1952. [모의 SW 역량테스트] 수영장

## 1월부터 12월까지 month를 돌면서 월마다 선택할 수 있는 지불 방식은 총 3가지 (1년권은 최대 금액이므로 논외로 침)
## 지불 방식을 선택하면서 다음 월로 이동하는 과정에서 지불 방식은 3가지밖에 없지만 12월까지 월마다 다 고려하면 
## 케이스가 너무 많아 for문, if문으로 판단하기 어렵다고 판단!

## point 1 : 그래서 발생할 수 있는 모든 경우를 다 본다고 생각 -> dfs 이용
## point 2 : 모든 경우를 보면서도 더이상 볼 필요가 없는 케이스는 쳐내줄 수 있을 것! -> 가지치기 이용

## 원하는 결과값은 누적합인데 이거 어디서 많이 본 것 같은 유형이란 생각이 듦
## 부분집합의 합이 최소인 거 찾는 문제 : dfs로 타고 가면서 total을 각 부분집합으로 포함할 원소를 더해주면서 depth + 1 해가던 문제
## 내려가다가 합이 현재의 최소보다 많으면 그냥 가지치기 해줬던 문제!
## 그리고 걔도 결국 합을 더해나가는 거였으니까 재귀형태로 dfs(현재 위치, depth, 누적합(total)) 형태!


def dfs(x, total):
    # 1. 일단 dfs로 들어왔다. 그럼 제일 먼저 해줘야 하는 건? 가지치기 조건 만들어주기!
    global min_fee

    # 현재까지의 더한 누적합이 벌써부터 min_fee를 초과함 -> 더 이상 볼 필요가 없음
    if total >= min_fee:
        return

    # 2. 근데 만약에 아직 min_fee를 안 넘어서 더 진행이 가능하다면?
    # min_fee 안 넘고 끝까지 모든 월을 돌았을 때도 종료!
    if x >= 13:
        # 지금까지 구한 min_fee를 넘기고 종료
        if total < min_fee:
            min_fee = total

        return min_fee

    # 3. 위의 두 조건에서 걸러지지 않는다면?
    # 여기로 dfs(1, 0)이 들어오면 해줘야 하는 게 뭐야! -> 다음 dfs로 안내해주는데 현재 step의 값들로 바꿔주고 보내줘야지

    # 1) 1일권 쓰는 경우
    dfs(x + 1, min(total + prices[0] * months[x - 1], total + prices[1] * 1))
    # 이렇게 되면 나 지금 현재 x에서 1일권 썼기때문에 그 다음 월로 months 리스트에서 한 칸만 움직일 거고!
    ## 현재 x에서 1일권 썼으니까 prices * 일수만큼 더해줄 거야!를 의미

    # 2) 1달권 쓰는 경우
    # dfs(x + 1, total + prices[1] * 1)

    # 3) 3달권 쓰는 경우
    dfs(x + 3, total + prices[2] * 1)


t = int(input())

for tc in range(1, t + 1):
    prices = list(map(int, input().split())) # 가격 정보 리스트
    months = list(map(int, input().split())) # 이용 계획 정보 리스트

    # 최솟값 찾는 문제니까 초기 최소값을 선언
    min_fee = prices[-1] # 얘가 제일 크기 때문에 1년권 사용하는 경우를 min_fee로 설정

    # 그럼 이제 1월에서 시작해서 달마다 모든 가지로 뻗어나가는 경우를 다 보는 걸 시작해야한다!
    dfs(1, 0) # 아직 누적합 0원이고, 1월달부터 보겠다!

    print(f'#{tc} {min_fee}')
